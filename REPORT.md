
# 1. 決定事項（今回の実装に当たり仕様として定めた内容）

## 1-1. importバッチのルール
- スケジュール機能によって1日に1回実施される。
- バッチが正常終了した際0、エラーが発生した場合は1を返す。
- データは全て登録するか全てロールバックするか。
    - 但し、user_data.csvとconsumptionは別とする。

## 1-2. user_data.csvの運用ルール
- ユーザの登録、削除、更新を行いたい場合、data配下に「user_data.csv」の名称にてファイルを配置する。
- CSVファイルにはユーザID、エリア名、プラン名の3つを揃えて全ユーザ分記載する。
- importバッチ実行時に上記のファイルが存在したら以下の処理を行う。
    - CSVファイル内のユーザデータをUserテーブルに格納する。
    - Userテーブルへの登録：×　 CSVファイル：〇 ＝　新規登録ユーザ
    - Userテーブルへの登録：〇　CSVファイル：×　＝　退会済みユーザ
    - Userテーブルへの登録：〇　CSVファイル：〇　エリア名・プラン名が異なる　＝　更新ユーザ
        - 更新ユーザの場合、新規の内容にて新しくデータを作成する。（従来のデータは削除せず履歴として残す）
    - ステータスが退会済みユーザが再度CSVファイルに記述されたらステータスを継続中に変更する
- データ登録後、user_data.csvファイルをcompletion/日付フォルダに移動する。
- データ登録・更新ができなかったユーザ情報をまとめたCSVファイルを別途作成する。

## 1-3. consumption CSVファイルの運用ルール
- 使用量が0khだとしてもCSVファイルに記載する。
- importバッチ実行前にdata/consumption配下に「{ユーザID}.csv」の名称にてファイルを配置する。
- importバッチ実行時に上記のファイルが存在したら以下の処理を行う。
    - CSVファイル内に格納されている消費量データをUserConsumptionHistoryテーブルに格納する。
- データ登録後、data/consumption配下のファイルをcompletion/日付フォルダに移動する。
- データ登録・更新ができなかった計測情報をまとめたCSVファイルを別途作成する。

## 1-4. CSVからのデータ取得及び、集計データの作成にはpandasを利用する

## 1-5. 集計画面の表示内容
- グラフ：過去の電力消費量を平日・休日に二分し、それぞれ時間帯毎の電力消費量をエリア別で表示する。
- 表：ユーザの一覧情報を表示
    - ユーザID、エリア、料金プラン、合計電力消費量を表示する
    - ユーザIDをクリックすることで、詳細画面に遷移できる。

## 1-6. 詳細画面には、以下を表示する
- 集計画面のグラフをユーザ単体で表示する。

## 1-7. 集計画面のグラフ表示用の集計データ
- 24Hキャッシュする。
- キャッシュにはRedisを使用する
- 以下の手順を実施してください。
    1. sudo apt-get update
    2. sudo apt-get install redis-server
    3. redis-server --port 6380

## 1-8. importバッチ内部のバリデーション
- user_dataの処理
    - マスタテーブルに存在しない値がCSVで指定されている場合
    - CSVファイル内部のidが重複している場合
    - ユーザID、エリア名、プラン名で空がある場合
    - ユーザID、プラン、エリアすべて一致するデータが既にDBに登録されている場合
- consumptionファイルの処理
    - CSVファイル名がユーザテーブルに存在しない値の場合
    - CSVファイル内部のdatetimeが重複している場合
        - 先に記載のあるデータを登録する。
    - ユーザIDと計測日時が一致するデータが既にDBに登録されている場合
    - ※時刻が完全一致していなければ30分おきでなくても登録できるようにする。

## 1-9.マスタデータの作成
- AreaやTariffPlanなどのマスタデータは、画面から作成できるようにする。
- 今回は期間の都合上、loaddataで入れれる用fixtureを作成しておく。（本番では使用しない想定）

<br><br><br>

# 2. 対応しきれなかった内容
## 2-1. フロントエンド
### 集計画面
- ユーザ一覧表のソート機能の実装
- ユーザ一覧表のページネーション機能 or 縦スクロール機能の実装 or 検索機能の実装
    - 縦長になっており使いづらい状況となっている。
### 詳細画面
- 集計画面へ戻るボタンの実装
- ユーザ情報の表示
### グラフ
- 縦軸のメモリ統一
    - 現状、平日と休日で縦軸のメモリ値が違うため、比較ができていない。
- グラフの色
    - 現在、平日・休日で同じ色を用いているのでそれぞれ違う色に変えたい。
- エリアが増えたときの確認がしきれていない。
- 深夜、朝、昼、夕方、夜がそれぞれどの時間帯を指しているのか分からない。
### 内部処理
- グラフ箇所はchart.htmlを作成し共通化したかった。
- create_chart.jsの処理を検討しきれていない。
    - Chartインスタンスの作成処理
    - 色の配列箇所
    - データセットの作成処理
### その他
- マスタデータの作成画面の作成

## 2-2. バックエンド
### ※各ファイルのdocstringに実装しきれていない機能等は記載しています
### その他
- テストコードの記述
- formatterなどlocalのみで使用するライブラリの扱い
    - requirements.txtに記述せずlocalでのみインストールしているが、開発専用のrequirement.txtなどを用意しても良かった。

<br><br><br>

# 3. 検討内容（仕様を固めるために検討・考慮した内容）
### ※体裁はある程度整えましたが、綺麗にまとめ切る時間が取れなかったため、少し煩雑になっております。
## 3-1. importバッチの処理タイミング
- 質問したところ1日1回を想定されているとのことだった。
    - とすると、CeleryやDjango-crontab、Amazon EventBridgeなどを用いたスケジューリング機能で定期実行するのが効率的である。
        - 実際にどの実装にするかは今回は検討外とする。

## 3-2. ユーザ情報の扱いについて
- user_data.csvに現ユーザの情報が記載されているが、実際の流れを考えると以下の内容なども想定される。
    - 新規契約をするユーザが発生する。
    - 他社への切り替え（退会）をするユーザが発生する。
    - CSVファイル内にある「area」「tariff」などの情報を変更するユーザが発生する。
        - tariffは料金プランとのことで、特に容易に変更されることが想像できる。
- ユーザ情報の連携方法としては、事業者側で管理しているユーザ情報をCSVファイルで連携されると想像する。
    - 本システムでもユーザのCUD機能を付けるのは2度手間となるため、連携されるCSVファイルからユーザのCUD機能を行える必要がある。
        - Create
            - user_idで一致するデータがDBに格納されていない場合、新規登録する。
        - Update
            - user_idで一致するデータがDBに格納されているが、areaとtariffどちらかの値が異なる場合、更新する。
                - summary画面やdetail画面にて、areaやtariffによる集計を検討する際にただ更新するだけだと、データ不整合が起こる。
                - そのため、更新の場合は過去の契約内容も履歴として残しておく必要がある。
        - Delete
            - DBに存在するuser_idがCSVファイルに存在しない場合は削除する（論理削除）
                - 退会していないが、CSVファイルから漏れている場合もあり得るので、論理削除にしておき復元できるようにする。
                    - 但し、復元機能は今回は実装しない。
- user_data.csvに以下のデータも載せてもらうことが理想ではある（事業者様側の仕様にもよると思うので本システムでは考慮外とした。）
    - ユーザのステータス
    - 契約開始日
    - 契約終了日
- もしくは、user_idを送ったらユーザ情報を返すAPIを実装してもらえると良いが、実現可能性は低そう
    - 事業者側にそういう依頼をできるのか？
    - 個人情報の観点からそこまで取得することが難しい？）
- また、追加、更新、削除するユーザのみCSVファイルに記載頂くのが理想的ではあるが、事業者側の対応によると思うので今回は考慮外とした。
- 処理済みユーザと未処理ユーザの区別を付けたい。
    - 未処理ユーザを並べたCSVファイルを新規作成する。
    - 消費量データも同様の仕様としたい。


## 3-3. Consumptionデータの扱いについて
- importバッチが毎日実行される場合、現存するCSVの中身を手動で書き換えるより、新しいCSVファイルを作成する方が運用上現実的であると考える。
    - 既存ファイルの更新は不可とし、データの登録・更新は新規ファイルを連携頂くことで、実施することとする。
        - 運用としては、import.pyの実行前にユーザごとの消費量CSVファイルのダウンロード処理が行われ、data/consumptionに格納されることを想定。（もしくは手動でその配下においてもらう。）
            - 過去の計測値が変わることはほとんど発生しない事象であると予測するため、登録済みの計測日時のデータは再登録及び更新は行わない。
                - テーブルにユーザIｄと計測日時でユニーク制約を付け、データの重複登録を省く。
            - もしデータ不整合が発生した場合はデータパッチ or 使い捨てバッチを作成して流す方針を取る。
                - 頻繁に発生する場合は、再検討する。
- 電力が何も消費されていなくても、0khという実績でCSVファイルに記録されることを想定している。
- importバッチが毎日実行されるのであれば、前日分（00:00:00～23:30:00）の消費量のみがCSVファイルで連携されることが理想ではある。（パフォーマンス的にも内部処理の容易性的にも）
    - 但し、そこは事業者側の仕様によると思うので、今回はCSVファイルで送られるデータは期間の指定ができない想定で進める。


## 3-4. CSVファイルの運用ルールについて
- まずデータ取り込み時のCSVファイルの扱いについて以下2パターンがあるが、案2を採用。
    1. CSV内のデータを変更して利用する。
        - 上記「Consumptionデータの扱いについて」において、CSVファイル内部のデータ変更は不可、データ変更したい場合は新規ファイルを作成することと定めたため、不採用
        - user_data.csvの扱いも統一する。
    2. 毎回新規ファイルを格納する。
        - 採用
- その上で、importバッチ実施後のファイルの扱いについて以下3パターンを検討し、案3を採用。
    1. なにもしない
        - メリット：
            - 追加処理を加える必要がない。
        - デメリット：
            - 実行時にどのファイルが対象となるのか分からない。
            - フォルダ内にある全ファイルを実行するとパフォーマンスが遅くなる。
    2. データ格納したCSVファイルを削除する。
        - メリット
            - 実行時の対象ファイルが明確になる。
        - デメリット
            - 履歴が残らないため、データ取り込みの検証ができない。
                - 別でCSVを保管しておく機能・仕組みが必要となる。
    3. データ格納したCSVファイルを使用済みフォルダに移動する。
        - メリット
            - 実行時の対象ファイルが明確になる。
            - 取り込んだデータの履歴としても残せる
        - デメリット
            - 永続的に保存するとファイル数が膨大になり容量を圧迫する
                - importバッチが毎日実行されるため、実行時に使用済みフォルダにあるファイルを全て消すことで対応可能になる。
                    - データ取り込み後24Hであれば確認できる。
                    - importバッチの中にcsvファイルの削除処理を加える。
                - ※但し、長期間保存を目的としてDBや外部ストレージ(Amazon S3など)への格納を検討擦る可能性もあり不明確なので、今回は削除機能は実装しない。


## 3-5. CSVファイルのデータの扱いについて
- CSVファイルからデータのインポートをするだけでなく、グラフ表示の為に列ごとのグルーピングや合計値の算出などを行う必要がある。
    - そのため、データ操作にはpandasを使用する。


## 3-6. Summary画面の表示内容について
- 事業者の課題として以下の2つがあると推測した。
    1. 電力自由化により、他社への切り替えが行われる可能性がある
        - 他社への切り替えを抑制するためにもユーザごとに適正プランの提案が必要か。
            - Summaryとして料金プラン別の軸で切った場合、どのプランが人気なのかなどは分かるが適正プランの提案へは繋がらない。
            - 料金プランごとの想定消費量などがあれば、その値との差異で適正プランを使用できているユーザの多少が測れそう。
                - 想定値との乖離があるプランのユーザを個別で見ていくことでユーザへの適正プランの提案に繋がりそう。
            - Summary画面にユーザ一覧の表を記載するが、そこに合計電力消費量を表示させ、並び替えをすることで適正なプランが申し込めているか確認できるようにする。
                - 適正な料金プランが使用されていれば、電力消費量のボリュームゾーンに応じて料金プランが固まるはずであると予測する。

    2. 電力の需給を合わせたい。
        - 電力使用量の把握はできるが、どの軸で切るか。
            - 季節：経年変化が見れないと示唆には繋がらなそう。
                - CSVファイルには2016年の6月～12月分しかないため、適さないと考える。
            - 時間帯：6か月分の平均値を取ることでおおよその値が算出できる。
                - 日中・夜中などの時間帯に応じて使用量の差が出ることが予測でき、現状のデータセットでも示唆が見えそう。
            - 曜日：これまでの6か月間のデータでも示唆が見出せるのではないか。
                - 平日・休日によって使用量の差が出ることが予測でき、現状のデータセットでも示唆が見えそう。
            - エリア：
                - 電力供給はエリアごとに行うはずなので、重要だと考える。
            - 料金プラン
                - 上記の理由により割愛
- 上記の内容を踏まえると、以下の形式でグラフ表示するのが良いと考える。
    - 平日・休日にてグラフを分ける。
    - 時間帯をある程度まとめて区分けする。
    - エリアごとに上記の内容を表示分けする。
- 理想としては、動的なグラフを作りたい。
    - 期間、エリア、料金プランを選択したらその値に応じた集計結果が算出される。
        - そのために、エリア・料金プランはマスタテーブルを作成しておく。
        - 今回の実装では工数の関係で実装しない。


## 3-7. 集計データの保持方法
- 以下の3パターンを検討。
- 今後変更が起こる可能性を考慮すると、変更容易性が高い方が良いためキャッシュを採用する。
1. 画面表示時に都度算出
    - メリット
        - リアルタイムにデータを反映できる。
    - デメリット
        - 1日に1回しかデータ更新が行われないので、都度算出するメリットがほぼない。
2. キャッシュを利用
    - メリット：
        - 表示データが変わったっとしても処理を変えるだけで良い。
        - DBの容量を食わない。
    - デメリット：履歴が保持できない。過去のデータを見る機能が追加された場合に新しく実装が必要。
3. データベースに保存
    - メリット：
        - 履歴を取れるため、過去データの参照等が低パフォーマンスで出来る。
    - デメリット：
        - 集計データが変わった時にテーブル定義から変更する必要があるため、柔軟性に乏しい。

- 表示するグラフが確定版ではなく、今後変更が起こる可能性を考慮すると変更容易性が高い方が良い。
    - その場合、DBではなくキャッシュで対応する。
        - キャッシュにはRedisを使用する。
            - 本来であればRedisの運用方法等も鑑みるべきだが、今回は工数を鑑みて、その辺りの考慮を割愛しとりあえず使える状況を取る。
                - settings.pyにも全て直書きする。

<br><br><br>

# 4. テーブル定義
###  時間が足りず書面に落としきれませんでした。<br>詳細はmodels配下のモデルクラスをご確認頂けますと幸いです。
## 4-1. エリアテーブル
| 論理名 | 物理名 | 型 | 桁数 | 主キー | Unique | NotNull | 備考 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| エリア名 | area_name | 型 | 桁数 | 主キー | Unique | NotNull | 備考 |

## 4-2.料金プランテーブル
| 論理名 | 物理名 | 型 | 桁数 | 主キー | Unique | NotNull | 備考 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

## 4-3. ユーザテーブル
| 論理名 | 物理名 | 型 | 桁数 | 主キー | Unique | NotNull | 備考 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

## 4-4. ユーザ契約履歴テーブル
| 論理名 | 物理名 | 型 | 桁数 | 主キー | Unique | NotNull | 備考 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

## 4-5. ユーザ消費履歴テーブル
| 論理名 | 物理名 | 型 | 桁数 | 主キー | Unique | NotNull | 備考 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |


<br><br>

## 5. QA
### 5-1. 1回目
1. Q：ユーザデータは1事業者を対象としている認識で相違ないでしょうか。
    - A：はい、相違ございません。
2. Q：area, tariffデータが示す役割を教えて頂きたいです。
    - Q：areaは対象事業者を利用しているユーザの居住地等によってカテゴライズされている認識です。
        - A：areaは電力供給エリアのことです。Challengeの値はa1などになっていますが、実際の弊社プロダクトには 北海道電力エリアなどの値が入っています。
    - Q：tariffは調べたところ「関税・税率」などと出てきたのですが、使われ方が分からなかったです。
        - A：tariffは電力料金プランのことです。
3. Q：パフォーマンスを考慮する際、ユーザ数はcsvファイルの60名を考慮すればよいか。他に指標があればご教示頂きたいです。
    - A：データ上は60人ですが、数万〜数十万人のアクセスに耐えうる設計ですとbetterです。
4. Q：docstringのスタイル含めて、則るべきコーディング規約はございますか。
    - A：docstringのスタイルなど指定はないですが、実際のプロダクトですと下記を使用しています。
        - numpydoc https://numpydoc.readthedocs.io/en/latest/format.html
        - black
        - isort
        - flake8
### 5-2. 2回目
1. Q：ユーザの詳細情報（ステータス（契約済み、解約）や契約期間など）は別テーブルで保持されている想定で良いでしょうか。
    - A：本チャレンジでは、csvに出力されている項目のみがユーザー情報になりますが、詳細情報が追加連携されることを想定した設計をしていただいても構いません。
2. Q：DBに登録したCSVファイルは削除せずそのまま残しておく方針でしょうか。
    - A：メリットデメリットを鑑みた上で、判断はお任せします。
3. Q：残す場合、CSVファイルの中身が書き換えられる可能性はありますか？
    - A：更新を考慮した設計であればベターです。更新を考慮しない場合は、その場合のcsvの連携ルール等をREPORT.mdに記載できていればよいと思います。
4. Q：次にimport.pyが呼び出された場合に、そのファイルを対象とするか否かで悩んでおります。
    - A：メリットデメリットを鑑みた上で、判断はお任せします。対象外とした場合は、csvの連携ルールに影響があるかと思いますので、REPORT.mdに記載できていればよいと思います。
5. Q：areaとtariffは別テーブルで保持していたりするのでしょうか。
    - A：DBの設計から行なっていただくのが本チャレンジになります。要件に対して最適なテーブル設計を大迫さんの方で考えていただけますと幸いです。
6. Q：a1(恐らく地域名)がareaテーブル（マスタテーブルを想定）に存在しない場合のバリデーションチェックを実装するべきか悩んでおります。
    - A：大迫さんの方で考えられるバリデーションを考慮した実装をお願いします。
7. Q：import.pyはどれくらいの間隔で呼び出される認識でしょうか。
    - A：1日1回のイメージです。